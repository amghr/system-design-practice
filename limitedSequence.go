//Part A) Write a program to print first N even, odd and fibonacci number. [We have already solved it]
//
//Part B) Extend Part A to support printing of first N LimitedEven and LimitedOdd.
//LimitedEven: This should generate even numbers upto a certain limit.
//For example,
//let us say LimitedEven(10) will generate numbers 0, 2, 4, 6, 8, 10, 10, 10 and so on.
//LimitedEven(9) will generate numbers 0, 2, 4, 6, 8, 8, 8, and so on.
//LimitedOdd(5) will generate numbers 1, 3, 5, 5, 5, 5, 5, and so on.
//

package main

import (
	"fmt"
	"log"
	"os"
	"strconv"
)

// NumberGenerator is an interface for generating the next number of any sequence
type NumberGenerator interface {
	Next() int
}

// EvenNumberGenerator generates even numbers, starting from a given value
type EvenNumberGenerator struct {
	curr int
}

// NewEvenNumberGenerator initializes the EvenNumberGenerator starting at 'start'
func NewEvenNumberGenerator(start int) *EvenNumberGenerator {
	return &EvenNumberGenerator{curr: start}
}

// Next function here returns the current number and increments the pointer to next even number
func (e *EvenNumberGenerator) Next() int {
	val := e.curr
	e.curr += 2
	return val
}

// OddNumberGenerator generates odd numbers, starting from a given value
type OddNumberGenerator struct {
	curr int
}

// NewOddNumberGenerator initializes the OddNumberGenerator starting at 'start'
func NewOddNumberGenerator(start int) *OddNumberGenerator {
	return &OddNumberGenerator{curr: start}
}

// Next function here returns the current number and increments the pointer to next odd number
func (o *OddNumberGenerator) Next() int {
	val := o.curr
	o.curr += 2
	return val
}

// FibonacciGenerator generates numbers in the Fibonacci sequence
type FibonacciGenerator struct {
	a, b int
}

// NewFibonacciGenerator initializes the FibonacciGenerator with a and b
func NewFibonacciGenerator(a, b int) *FibonacciGenerator {
	return &FibonacciGenerator{a: a, b: b}
}

// Next function here returns the next number in the fibonacci sequence
func (f *FibonacciGenerator) Next() int {
	res := f.a
	f.a, f.b = f.b, f.a+f.b
	return res
}

// PrintNumbers prints 'n' numbers generated by the provided NumberGenerator
func PrintNumbers(n int, gen NumberGenerator) {
	for i := 0; i < n; i++ {
		num := gen.Next()
		fmt.Print(num, " ")
	}
	fmt.Print("\n")
}

// PrintLimitedSequence limits the sequence after a given limit
func PrintLimitedSequence(n int, gen NumberGenerator) {
	lastValid := 0
	for i := 0; i < n; i++ {
		num := gen.Next()
		if num > n {
			fmt.Print(lastValid, " ")
		} else {
			fmt.Print(num, " ")
			lastValid = num
		}
	}
	fmt.Print("\n")
}

func main() {
	if len(os.Args) < 4 {
		fmt.Println("Usage: go run evenOdd.go even|odd full|lim N")
		os.Exit(1)
	}

	mode := os.Args[1]
	sequenceType := os.Args[2]

	n, err := strconv.Atoi(os.Args[3])
	if err != nil || n < 1 {
		log.Fatalf("Error: '%v' is not a valid number of elements.", os.Args[2])
	}

	var gen NumberGenerator
	switch mode {
	case "even":
		gen = NewEvenNumberGenerator(0)
	case "odd":
		gen = NewOddNumberGenerator(1)
	case "fib":
		gen = NewFibonacciGenerator(0, 1)
	}

	if sequenceType == "full" {
		PrintNumbers(n, gen)
	} else if sequenceType == "lim" {
		PrintLimitedSequence(n, gen)
	}
}
